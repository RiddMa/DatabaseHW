## 第四章「中级 SQL」

### 4.1 连接表达式

#### 连接条件

* 「on」条件

```mysql
select * from student join takes on student.ID = takes.ID;
```
与「natural join」类似，区别在于「on」连接查询结果中 ID 属性出现两次。

* 如何只显示一次 ID？

```mysql
select student.ID as ID, name, dept_name, tot_cred, course_id, sec_id, semester, year, grade
from student join takes on student.ID = take.ID;
```

#### 外连接

* 「外连接」（outer join）在结果中创建包含null 的元组，保留在「连接」中丢失的元组。
* 「左外连接」（left outer join）保留运算符左侧关系中的元组，「右外连接」（right outer join）、「全外连接」（full outer join）同理。
* 查询Comp. Sci. 系学生以及他们 2009 年春季能选修的所有课程段：

```mysql
select *
from(select *
    from student
    where dept_name = 'Comp. Sci.')
    natural full outer join
    (select *
    from takes
    where semester = 'Spring' and year = 2009)
```

* on 和 where 的区别：on 条件在使用中是「外连接」声明的一部分，但 where 不是，使用 where 并不会产生补上空值的元组。（见中文书 p66）

#### 连接类型和条件

* 「join」默认等价于「inner join」

	连接类型				连接条件

	inner join				natural

	left outer join

	// to be done			

### 4.2 视图

* SQL 允许通过查询来定义「虚关系」，它在概念上包含查询结果，但并不预先存储，而是在使用该虚关系时才通过执行查询被计算出来，因此不像预先计算存储的数据会过期。

* 这种不是「逻辑模型」的一部分，但作为「虚关系」对用户可见的关系成为「视图」（view）。

#### 视图定义

* 创建视图：

``` mysql
create view v as <query expression>;
```

e.g.

```mysql
create view faculty as
select ID, name, dept_name
from instructor;
```

#### SQL 查询中使用视图

* 可以使用视图名来指代该虚关系。e.g.

```mysql
select name
from faculty
where dept_name = 'Comp. Sci.';
```

* 可以给通过计算产生的视图的属性赋予名称：

```mysql
create view departments_total_salary(dept_name, total_salary) as
select dept_name, sum(salary)
from instructor
group by dept_name;
```

* 「视图」支持嵌套，可以「from」一个视图中创建一个新的视图。

#### 物化视图

* 「物化视图」（materialized view）：可以存储的视图关系，它的结果会存储在数据库中，但是如果原来的「关系」发生改变，物化视图的内容也必须随之更新。
* 保持物化视图一直在最新状态的过程称为「物化视图维护」（materialized view maintenance），简称「视图维护」。有三种维护方式：
	* 当构成视图定义的任何关系被更新时，立即进行视图维护。
	* 在视图被访问时，进行视图维护。
	* 周期性视图维护（可能访问到陈旧数据）。
* 「物化视图」使得频繁使用视图的应用响应速度加快，但同时增加了存储与更新开销。

#### 视图更新

* 对查询而言视图很好用，但是如果进行更新、插入或删除，可能带来严重问题：用视图表达的修改必须翻译为对数据库逻辑模型实际关系的修改。
* 如果一个视图可以满足下列查询条件，则称这个视图是「可更新的」：
	* 「from」子句中只有一个数据库关系。
	* 「select」子句只包含关系的属性名，不包含任何「表达式」、「聚集」或「distinct 」声明。
	* 任何没有出现在「select」子句的属性可以取空值；即使这些属性上没有「not null」约束， 也不构成「primary key」的一部分。
	* 查询中不含有「group by」或「having」子句。
* 「可更新」的视图举例：

```mysql
create view history_instructors as
select * 
from instructor
where dept_name = 'History';
```

* 在视图定义的结尾加上「with check option」子句可以让数据库在执行 CRUD 操作时确认，是否会破坏视图的「可更新」性。

### 4.3 事务（transaction）

* 「事务」由「查询」和（或）「更新」语句的序列组成。当一条 SQL 语句被执行，就隐式地开始了一个事务。下列 SQL 语句之一会结束一个事务：
	* 「Commit Work」：提交当前事务，将该事务所做的更新在数据库中持久保存。在事务被提交之后，一个新的事务自动开始。
	* 「Rollback Work」：回滚当前事务，撤销该事务中所有 SQL 语句对数据库的更新。恢复到执行该事务第一条语句之前的状态。
* 通过这种方式，数据库提供了对「事务」具有「原子性」（atomic）的抽象。
* SQL:1999标准可以使用下列语句包裹 SQL 语句执行一个事务：
```mysql
begin atomic ... end
#但是对于该标准的实现取决于不同的SQL实现。
```

### 4.4 完整性约束

* 完整性约束保证授权用户对数据库的修改不会破坏数据的一致性。
* 第八章将学习一种被称作「函数依赖」的完整性约束形式，主要应用在模式设计的过程中。
* 完整性约束通常是数据库模式设计过程的一部分，作为创建关系的「create table」命令的一部分被声明。完整性约束也可以通过

```mysql
alter table x add xxxconstraint
```

* 命令加到已有关系。

#### 单个关系上的约束

```mysql
#有
not null
unique
check(<谓词>)
#三种。
```

#### not null 约束

```mysql
name varchar(20) not null
budget numeric(12,2) not null
```

* 任何可能导致向一个声明为「not null」的属性插入空值的操作都会产生错误诊断信息。

#### unique 约束

```mysql
unique(Aj1, Aj2, Aj3, ..., Ajm)
```

* 该声明指出括号内的属性形成了一个「候选码」，即在关系中，没有两个元组能在所有列出的属性上取值相同。然而「候选码」属性可以为「null」，除非已经被显式声明为「not null」。

#### check 子句

* 限制属性的取值域必须在特定范围内。

```mysql
create table section(
  course_id varchar(8),
  sec_id varchar(8),
	semester varchar(6),
	years numeric(4,0),
	building varchar(15),
	room_number varchar(7),
	time_slot_id varchar(4),
	primary key(course_id, sec_id, semester, years),
	check(semester in ('Fall','Winter','Spring','Summer')));
```

#### 参照完整性

* 在一个关系中，给定属性集上的取值，也在另一关系的特定属性集的取值中出现，这种情况称为「参照完整性」（referential integrity）。
* 例如：「外码」`foreign key(dept_name) references department`声明了在每个课程元祖中，指定的 dept_name 必须在department 关系中存在。这种要求被称为「参照完整性约束」（referential-integrity constraint）或「子集依赖」（subset dependency）。
* 可以进行如下声明：如果被参照关系上的删除或者更新动作违反了约束，那么系统采取一些步骤通过修改参照关系中的元组来恢复完整性约束。如：

```mysql
create table course
(...
foreign key(dept_name)references deparment
	on delete cascade
	on update cascade,
...);
```

* 由于「on delete cascade」子句，如果删除 department 中的元组导致了此参照完整性约束被违反，则系统对 course 关系做「级联」删除，即删除参照了被删除系的元组。同理，「on update cascade」可以对被参照元组的 dept_name 字段实现「级联」更新。也可以使用「set null」或者「set default」替代「cascade」。

#### 事务中对完整性约束的违反

#### 复杂 check 条件与断言

### 4.5SQL 的数据类型与模式

#### SQL 中的日期和时间类型

